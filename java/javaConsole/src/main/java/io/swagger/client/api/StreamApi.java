/**
 * Developer API
 * Documentation of worker endpoints
 *
 * OpenAPI spec version: 2.2
 * Contact: info@nviso.ch
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package io.swagger.client.api;

import io.swagger.client.ApiCallback;
import io.swagger.client.ApiClient;
import io.swagger.client.ApiException;
import io.swagger.client.ApiResponse;
import io.swagger.client.Configuration;
import io.swagger.client.Pair;
import io.swagger.client.ProgressRequestBody;
import io.swagger.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;

import java.io.File;
import io.swagger.client.model.Key;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class StreamApi {
    private ApiClient apiClient;

    public StreamApi() {
        this(Configuration.getDefaultApiClient());
    }

    public StreamApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /* Build call for streamDelete */
    private com.squareup.okhttp.Call streamDeleteCall(String sessionKey, String appId, String appKey, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'sessionKey' is set
        if (sessionKey == null) {
            throw new ApiException("Missing the required parameter 'sessionKey' when calling streamDelete(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stream/delete".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (sessionKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sessionKey", sessionKey));
        if (appId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appId", appId));
        if (appKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appKey", appKey));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Delete all stored data for a given unique session key.
     * Delete all stored data for a given unique session key.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String streamDelete(String sessionKey, String appId, String appKey) throws ApiException {
        ApiResponse<String> resp = streamDeleteWithHttpInfo(sessionKey, appId, appKey);
        return resp.getData();
    }

    /**
     * Delete all stored data for a given unique session key.
     * Delete all stored data for a given unique session key.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> streamDeleteWithHttpInfo(String sessionKey, String appId, String appKey) throws ApiException {
        com.squareup.okhttp.Call call = streamDeleteCall(sessionKey, appId, appKey, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Delete all stored data for a given unique session key. (asynchronously)
     * Delete all stored data for a given unique session key.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call streamDeleteAsync(String sessionKey, String appId, String appKey, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = streamDeleteCall(sessionKey, appId, appKey, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for streamEnd */
    private com.squareup.okhttp.Call streamEndCall(String sessionKey, String appId, String appKey, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'sessionKey' is set
        if (sessionKey == null) {
            throw new ApiException("Missing the required parameter 'sessionKey' when calling streamEnd(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stream/end".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (sessionKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sessionKey", sessionKey));
        if (appId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appId", appId));
        if (appKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appKey", appKey));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * End a session for a given unique session key.
     * End a stream for a given unique session key.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String streamEnd(String sessionKey, String appId, String appKey) throws ApiException {
        ApiResponse<String> resp = streamEndWithHttpInfo(sessionKey, appId, appKey);
        return resp.getData();
    }

    /**
     * End a session for a given unique session key.
     * End a stream for a given unique session key.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> streamEndWithHttpInfo(String sessionKey, String appId, String appKey) throws ApiException {
        com.squareup.okhttp.Call call = streamEndCall(sessionKey, appId, appKey, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * End a session for a given unique session key. (asynchronously)
     * End a stream for a given unique session key.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call streamEndAsync(String sessionKey, String appId, String appKey, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = streamEndCall(sessionKey, appId, appKey, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for streamList */
    private com.squareup.okhttp.Call streamListCall(String ID, String appId, String appKey, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'ID' is set
        if (ID == null) {
            throw new ApiException("Missing the required parameter 'ID' when calling streamList(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stream/list".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (ID != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "ID", ID));
        if (appId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appId", appId));
        if (appKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appKey", appKey));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * List of streams and status information for a given ID or wildcard search.
     * List of streams and status information for a given ID or wildcard search. Status information includes if streams have been ended, the count of faces, duration of the stream, and supplied metadata when the stream was started.
     * @param ID ID used for starting the sessions. Use the character % if you don&#39;t know a part of the ID. For example, %test%. (required)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String streamList(String ID, String appId, String appKey) throws ApiException {
        ApiResponse<String> resp = streamListWithHttpInfo(ID, appId, appKey);
        return resp.getData();
    }

    /**
     * List of streams and status information for a given ID or wildcard search.
     * List of streams and status information for a given ID or wildcard search. Status information includes if streams have been ended, the count of faces, duration of the stream, and supplied metadata when the stream was started.
     * @param ID ID used for starting the sessions. Use the character % if you don&#39;t know a part of the ID. For example, %test%. (required)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> streamListWithHttpInfo(String ID, String appId, String appKey) throws ApiException {
        com.squareup.okhttp.Call call = streamListCall(ID, appId, appKey, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * List of streams and status information for a given ID or wildcard search. (asynchronously)
     * List of streams and status information for a given ID or wildcard search. Status information includes if streams have been ended, the count of faces, duration of the stream, and supplied metadata when the stream was started.
     * @param ID ID used for starting the sessions. Use the character % if you don&#39;t know a part of the ID. For example, %test%. (required)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call streamListAsync(String ID, String appId, String appKey, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = streamListCall(ID, appId, appKey, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for streamProcessBase64 */
    private com.squareup.okhttp.Call streamProcessBase64Call(String base64, String sessionKey, Double score, Double time, Double timestamp, String format, String distance, Boolean multipleFaces, Double xMin, Double xMax, Double yMin, Double yMax, Boolean enableFooter, Boolean dimSecFaces, String appId, String appKey, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = base64;
        
        // verify the required parameter 'base64' is set
        if (base64 == null) {
            throw new ApiException("Missing the required parameter 'base64' when calling streamProcessBase64(Async)");
        }
        
        // verify the required parameter 'sessionKey' is set
        if (sessionKey == null) {
            throw new ApiException("Missing the required parameter 'sessionKey' when calling streamProcessBase64(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stream/process/base64".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (sessionKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sessionKey", sessionKey));
        if (score != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "score", score));
        if (time != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "time", time));
        if (timestamp != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "timestamp", timestamp));
        if (format != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "format", format));
        if (distance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "distance", distance));
        if (multipleFaces != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "multipleFaces", multipleFaces));
        if (xMin != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "xMin", xMin));
        if (xMax != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "xMax", xMax));
        if (yMin != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "yMin", yMin));
        if (yMax != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "yMax", yMax));
        if (enableFooter != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "enableFooter", enableFooter));
        if (dimSecFaces != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "dimSecFaces", dimSecFaces));
        if (appId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appId", appId));
        if (appKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appKey", appKey));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "text/plain"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Process an uploaded Base64 String of a time sequence photo encoded in JPEG or PNG format returning result in a JSON format.
     * Process an uploaded Base64 String of a time sequence photo encoded in JPEG or PNG format returning result in a JSON format. Same options and behavior as /stream/process/upload end point.
     * @param base64 Base 64 encoded image (required)
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param score Score defines the order of the images. Image with lowest score will first in the sequence. If score is not set, then the order will done on the timestamp. (optional)
     * @param time Relative time of the video. Default is 0.0. (optional)
     * @param timestamp Specific timestamp for the picture in the session in UNIX time. Default is the time when you process the image. (optional)
     * @param format Format of the JSON response. Default is v2-Full. (optional)
     * @param distance Distance is the distance at which the picture was taken. Near &#x3D; 1.5 m; Medium &#x3D; 3 m; Far &gt; 3 m. Default value is near. (optional)
     * @param multipleFaces If there are multiple faces in the region of interest, then you need to put this value to True. Default value is true. (optional)
     * @param xMin Minimum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param xMax Maximum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param yMin Minimum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param yMax Maximum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param enableFooter Enable the footer with more information on the emotions. Default value is true. (This value is used when rendering the session) (optional)
     * @param dimSecFaces If set to true, it will dim all the secondary faces. Default value is true. (This value is used when rendering the session) (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String streamProcessBase64(String base64, String sessionKey, Double score, Double time, Double timestamp, String format, String distance, Boolean multipleFaces, Double xMin, Double xMax, Double yMin, Double yMax, Boolean enableFooter, Boolean dimSecFaces, String appId, String appKey) throws ApiException {
        ApiResponse<String> resp = streamProcessBase64WithHttpInfo(base64, sessionKey, score, time, timestamp, format, distance, multipleFaces, xMin, xMax, yMin, yMax, enableFooter, dimSecFaces, appId, appKey);
        return resp.getData();
    }

    /**
     * Process an uploaded Base64 String of a time sequence photo encoded in JPEG or PNG format returning result in a JSON format.
     * Process an uploaded Base64 String of a time sequence photo encoded in JPEG or PNG format returning result in a JSON format. Same options and behavior as /stream/process/upload end point.
     * @param base64 Base 64 encoded image (required)
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param score Score defines the order of the images. Image with lowest score will first in the sequence. If score is not set, then the order will done on the timestamp. (optional)
     * @param time Relative time of the video. Default is 0.0. (optional)
     * @param timestamp Specific timestamp for the picture in the session in UNIX time. Default is the time when you process the image. (optional)
     * @param format Format of the JSON response. Default is v2-Full. (optional)
     * @param distance Distance is the distance at which the picture was taken. Near &#x3D; 1.5 m; Medium &#x3D; 3 m; Far &gt; 3 m. Default value is near. (optional)
     * @param multipleFaces If there are multiple faces in the region of interest, then you need to put this value to True. Default value is true. (optional)
     * @param xMin Minimum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param xMax Maximum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param yMin Minimum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param yMax Maximum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param enableFooter Enable the footer with more information on the emotions. Default value is true. (This value is used when rendering the session) (optional)
     * @param dimSecFaces If set to true, it will dim all the secondary faces. Default value is true. (This value is used when rendering the session) (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> streamProcessBase64WithHttpInfo(String base64, String sessionKey, Double score, Double time, Double timestamp, String format, String distance, Boolean multipleFaces, Double xMin, Double xMax, Double yMin, Double yMax, Boolean enableFooter, Boolean dimSecFaces, String appId, String appKey) throws ApiException {
        com.squareup.okhttp.Call call = streamProcessBase64Call(base64, sessionKey, score, time, timestamp, format, distance, multipleFaces, xMin, xMax, yMin, yMax, enableFooter, dimSecFaces, appId, appKey, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Process an uploaded Base64 String of a time sequence photo encoded in JPEG or PNG format returning result in a JSON format. (asynchronously)
     * Process an uploaded Base64 String of a time sequence photo encoded in JPEG or PNG format returning result in a JSON format. Same options and behavior as /stream/process/upload end point.
     * @param base64 Base 64 encoded image (required)
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param score Score defines the order of the images. Image with lowest score will first in the sequence. If score is not set, then the order will done on the timestamp. (optional)
     * @param time Relative time of the video. Default is 0.0. (optional)
     * @param timestamp Specific timestamp for the picture in the session in UNIX time. Default is the time when you process the image. (optional)
     * @param format Format of the JSON response. Default is v2-Full. (optional)
     * @param distance Distance is the distance at which the picture was taken. Near &#x3D; 1.5 m; Medium &#x3D; 3 m; Far &gt; 3 m. Default value is near. (optional)
     * @param multipleFaces If there are multiple faces in the region of interest, then you need to put this value to True. Default value is true. (optional)
     * @param xMin Minimum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param xMax Maximum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param yMin Minimum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param yMax Maximum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param enableFooter Enable the footer with more information on the emotions. Default value is true. (This value is used when rendering the session) (optional)
     * @param dimSecFaces If set to true, it will dim all the secondary faces. Default value is true. (This value is used when rendering the session) (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call streamProcessBase64Async(String base64, String sessionKey, Double score, Double time, Double timestamp, String format, String distance, Boolean multipleFaces, Double xMin, Double xMax, Double yMin, Double yMax, Boolean enableFooter, Boolean dimSecFaces, String appId, String appKey, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = streamProcessBase64Call(base64, sessionKey, score, time, timestamp, format, distance, multipleFaces, xMin, xMax, yMin, yMax, enableFooter, dimSecFaces, appId, appKey, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for streamProcessUpload */
    private com.squareup.okhttp.Call streamProcessUploadCall(File file, String sessionKey, Double score, Double time, Double timestamp, String format, String distance, Boolean multipleFaces, Double xMin, Double xMax, Double yMin, Double yMax, Boolean enableFooter, Boolean dimSecFaces, String appId, String appKey, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'file' is set
        if (file == null) {
            throw new ApiException("Missing the required parameter 'file' when calling streamProcessUpload(Async)");
        }
        
        // verify the required parameter 'sessionKey' is set
        if (sessionKey == null) {
            throw new ApiException("Missing the required parameter 'sessionKey' when calling streamProcessUpload(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stream/process/upload".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (sessionKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sessionKey", sessionKey));
        if (score != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "score", score));
        if (time != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "time", time));
        if (timestamp != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "timestamp", timestamp));
        if (format != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "format", format));
        if (distance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "distance", distance));
        if (multipleFaces != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "multipleFaces", multipleFaces));
        if (xMin != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "xMin", xMin));
        if (xMax != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "xMax", xMax));
        if (yMin != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "yMin", yMin));
        if (yMax != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "yMax", yMax));
        if (enableFooter != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "enableFooter", enableFooter));
        if (dimSecFaces != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "dimSecFaces", dimSecFaces));
        if (appId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appId", appId));
        if (appKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appKey", appKey));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();
        if (file != null)
        localVarFormParams.put("file", file);

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Process an uploaded time sequence photo encoded in JPEG or PNG format returning result in a JSON format.
     * Process an uploaded time sequence image encoded in JPEG or PNG format returning result in a JSON format. Normally images provided to this end point are captured from a webcam or video stream of a fixed size for the entire session. The results are stored in a database using the provided session key and can be scored for ordering based on an optional score. Time information regarding the sequence of the image is provided as both a relative time as elapsed time in seconds from a user defined reference and as an absolute UNIX timestamp. If no time information is provided, a UNIX timestamp represented the time the image was processed is used as default.    Options that can be set to process the image include specifying if multiple faces should be detected, the distance of the faces that should be detected from the camera, and if a region of interest should be set to restrict processing of faces within the specified region of interest.
     * @param file File to post to the API. (required)
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param score Score defines the order of the images. Image with lowest score will first in the sequence. If score is not set, then the order will done on the timestamp. (optional)
     * @param time Relative time of the video. Default is 0.0. (optional)
     * @param timestamp Specific timestamp for the picture in the session in UNIX time. Default is the time when you process the image. (optional)
     * @param format Format of the JSON response. Default is v2-Full. (optional)
     * @param distance Distance is the distance at which the picture was taken. Near &#x3D; 1.5 m; Medium &#x3D; 3 m; Far &gt; 3 m. Default value is near. (optional)
     * @param multipleFaces If there are multiple faces in the region of interest, then you need to put this value to True. Default value is true. (optional)
     * @param xMin Minimum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param xMax Maximum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param yMin Minimum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param yMax Maximum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param enableFooter Enable the footer with more information on the emotions. Default value is true. (This value is used when rendering the session) (optional)
     * @param dimSecFaces If set to true, it will dim all the secondary faces. Default value is true. (This value is used when rendering the session) (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String streamProcessUpload(File file, String sessionKey, Double score, Double time, Double timestamp, String format, String distance, Boolean multipleFaces, Double xMin, Double xMax, Double yMin, Double yMax, Boolean enableFooter, Boolean dimSecFaces, String appId, String appKey) throws ApiException {
        ApiResponse<String> resp = streamProcessUploadWithHttpInfo(file, sessionKey, score, time, timestamp, format, distance, multipleFaces, xMin, xMax, yMin, yMax, enableFooter, dimSecFaces, appId, appKey);
        return resp.getData();
    }

    /**
     * Process an uploaded time sequence photo encoded in JPEG or PNG format returning result in a JSON format.
     * Process an uploaded time sequence image encoded in JPEG or PNG format returning result in a JSON format. Normally images provided to this end point are captured from a webcam or video stream of a fixed size for the entire session. The results are stored in a database using the provided session key and can be scored for ordering based on an optional score. Time information regarding the sequence of the image is provided as both a relative time as elapsed time in seconds from a user defined reference and as an absolute UNIX timestamp. If no time information is provided, a UNIX timestamp represented the time the image was processed is used as default.    Options that can be set to process the image include specifying if multiple faces should be detected, the distance of the faces that should be detected from the camera, and if a region of interest should be set to restrict processing of faces within the specified region of interest.
     * @param file File to post to the API. (required)
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param score Score defines the order of the images. Image with lowest score will first in the sequence. If score is not set, then the order will done on the timestamp. (optional)
     * @param time Relative time of the video. Default is 0.0. (optional)
     * @param timestamp Specific timestamp for the picture in the session in UNIX time. Default is the time when you process the image. (optional)
     * @param format Format of the JSON response. Default is v2-Full. (optional)
     * @param distance Distance is the distance at which the picture was taken. Near &#x3D; 1.5 m; Medium &#x3D; 3 m; Far &gt; 3 m. Default value is near. (optional)
     * @param multipleFaces If there are multiple faces in the region of interest, then you need to put this value to True. Default value is true. (optional)
     * @param xMin Minimum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param xMax Maximum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param yMin Minimum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param yMax Maximum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param enableFooter Enable the footer with more information on the emotions. Default value is true. (This value is used when rendering the session) (optional)
     * @param dimSecFaces If set to true, it will dim all the secondary faces. Default value is true. (This value is used when rendering the session) (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> streamProcessUploadWithHttpInfo(File file, String sessionKey, Double score, Double time, Double timestamp, String format, String distance, Boolean multipleFaces, Double xMin, Double xMax, Double yMin, Double yMax, Boolean enableFooter, Boolean dimSecFaces, String appId, String appKey) throws ApiException {
        com.squareup.okhttp.Call call = streamProcessUploadCall(file, sessionKey, score, time, timestamp, format, distance, multipleFaces, xMin, xMax, yMin, yMax, enableFooter, dimSecFaces, appId, appKey, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Process an uploaded time sequence photo encoded in JPEG or PNG format returning result in a JSON format. (asynchronously)
     * Process an uploaded time sequence image encoded in JPEG or PNG format returning result in a JSON format. Normally images provided to this end point are captured from a webcam or video stream of a fixed size for the entire session. The results are stored in a database using the provided session key and can be scored for ordering based on an optional score. Time information regarding the sequence of the image is provided as both a relative time as elapsed time in seconds from a user defined reference and as an absolute UNIX timestamp. If no time information is provided, a UNIX timestamp represented the time the image was processed is used as default.    Options that can be set to process the image include specifying if multiple faces should be detected, the distance of the faces that should be detected from the camera, and if a region of interest should be set to restrict processing of faces within the specified region of interest.
     * @param file File to post to the API. (required)
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param score Score defines the order of the images. Image with lowest score will first in the sequence. If score is not set, then the order will done on the timestamp. (optional)
     * @param time Relative time of the video. Default is 0.0. (optional)
     * @param timestamp Specific timestamp for the picture in the session in UNIX time. Default is the time when you process the image. (optional)
     * @param format Format of the JSON response. Default is v2-Full. (optional)
     * @param distance Distance is the distance at which the picture was taken. Near &#x3D; 1.5 m; Medium &#x3D; 3 m; Far &gt; 3 m. Default value is near. (optional)
     * @param multipleFaces If there are multiple faces in the region of interest, then you need to put this value to True. Default value is true. (optional)
     * @param xMin Minimum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param xMax Maximum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param yMin Minimum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param yMax Maximum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param enableFooter Enable the footer with more information on the emotions. Default value is true. (This value is used when rendering the session) (optional)
     * @param dimSecFaces If set to true, it will dim all the secondary faces. Default value is true. (This value is used when rendering the session) (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call streamProcessUploadAsync(File file, String sessionKey, Double score, Double time, Double timestamp, String format, String distance, Boolean multipleFaces, Double xMin, Double xMax, Double yMin, Double yMax, Boolean enableFooter, Boolean dimSecFaces, String appId, String appKey, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = streamProcessUploadCall(file, sessionKey, score, time, timestamp, format, distance, multipleFaces, xMin, xMax, yMin, yMax, enableFooter, dimSecFaces, appId, appKey, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for streamProcessUrl */
    private com.squareup.okhttp.Call streamProcessUrlCall(String url, String sessionKey, Double score, Double time, Double timestamp, String format, String distance, Boolean multipleFaces, Double xMin, Double xMax, Double yMin, Double yMax, Boolean enableFooter, Boolean dimSecFaces, String appId, String appKey, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'url' is set
        if (url == null) {
            throw new ApiException("Missing the required parameter 'url' when calling streamProcessUrl(Async)");
        }
        
        // verify the required parameter 'sessionKey' is set
        if (sessionKey == null) {
            throw new ApiException("Missing the required parameter 'sessionKey' when calling streamProcessUrl(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stream/process/url".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (url != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "url", url));
        if (sessionKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sessionKey", sessionKey));
        if (score != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "score", score));
        if (time != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "time", time));
        if (timestamp != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "timestamp", timestamp));
        if (format != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "format", format));
        if (distance != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "distance", distance));
        if (multipleFaces != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "multipleFaces", multipleFaces));
        if (xMin != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "xMin", xMin));
        if (xMax != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "xMax", xMax));
        if (yMin != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "yMin", yMin));
        if (yMax != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "yMax", yMax));
        if (enableFooter != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "enableFooter", enableFooter));
        if (dimSecFaces != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "dimSecFaces", dimSecFaces));
        if (appId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appId", appId));
        if (appKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appKey", appKey));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Process a JPEG or PNG time sequence image downloaded from provided URL returning result in a JSON format.
     * Process a JPEG or PNG time sequence image downloaded from provided URL returning result in a JSON format. Same options and behavior as /stream/process/upload end point.
     * @param url URL to upload the picture (required)
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param score Score defines the order of the images. Image with lowest score will first in the sequence. If score is not set, then the order will done on the timestamp. (optional)
     * @param time Relative time of the video. Default is 0.0. (optional)
     * @param timestamp Specific timestamp for the picture in the session in UNIX time. Default is the time when you process the image. (optional)
     * @param format Format of the JSON response. Default is v2-Full. (optional)
     * @param distance Distance is the distance at which the picture was taken. Near &#x3D; 1.5 m; Medium &#x3D; 3 m; Far &gt; 3 m. Default value is near. (optional)
     * @param multipleFaces If there are multiple faces in the region of interest, then you need to put this value to True. Default value is true. (optional)
     * @param xMin Minimum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param xMax Maximum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param yMin Minimum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param yMax Maximum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param enableFooter Enable the footer with more information on the emotions. Default value is true. (This value is used when rendering the session) (optional)
     * @param dimSecFaces If set to true, it will dim all the secondary faces. Default value is true. (This value is used when rendering the session) (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String streamProcessUrl(String url, String sessionKey, Double score, Double time, Double timestamp, String format, String distance, Boolean multipleFaces, Double xMin, Double xMax, Double yMin, Double yMax, Boolean enableFooter, Boolean dimSecFaces, String appId, String appKey) throws ApiException {
        ApiResponse<String> resp = streamProcessUrlWithHttpInfo(url, sessionKey, score, time, timestamp, format, distance, multipleFaces, xMin, xMax, yMin, yMax, enableFooter, dimSecFaces, appId, appKey);
        return resp.getData();
    }

    /**
     * Process a JPEG or PNG time sequence image downloaded from provided URL returning result in a JSON format.
     * Process a JPEG or PNG time sequence image downloaded from provided URL returning result in a JSON format. Same options and behavior as /stream/process/upload end point.
     * @param url URL to upload the picture (required)
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param score Score defines the order of the images. Image with lowest score will first in the sequence. If score is not set, then the order will done on the timestamp. (optional)
     * @param time Relative time of the video. Default is 0.0. (optional)
     * @param timestamp Specific timestamp for the picture in the session in UNIX time. Default is the time when you process the image. (optional)
     * @param format Format of the JSON response. Default is v2-Full. (optional)
     * @param distance Distance is the distance at which the picture was taken. Near &#x3D; 1.5 m; Medium &#x3D; 3 m; Far &gt; 3 m. Default value is near. (optional)
     * @param multipleFaces If there are multiple faces in the region of interest, then you need to put this value to True. Default value is true. (optional)
     * @param xMin Minimum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param xMax Maximum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param yMin Minimum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param yMax Maximum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param enableFooter Enable the footer with more information on the emotions. Default value is true. (This value is used when rendering the session) (optional)
     * @param dimSecFaces If set to true, it will dim all the secondary faces. Default value is true. (This value is used when rendering the session) (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> streamProcessUrlWithHttpInfo(String url, String sessionKey, Double score, Double time, Double timestamp, String format, String distance, Boolean multipleFaces, Double xMin, Double xMax, Double yMin, Double yMax, Boolean enableFooter, Boolean dimSecFaces, String appId, String appKey) throws ApiException {
        com.squareup.okhttp.Call call = streamProcessUrlCall(url, sessionKey, score, time, timestamp, format, distance, multipleFaces, xMin, xMax, yMin, yMax, enableFooter, dimSecFaces, appId, appKey, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Process a JPEG or PNG time sequence image downloaded from provided URL returning result in a JSON format. (asynchronously)
     * Process a JPEG or PNG time sequence image downloaded from provided URL returning result in a JSON format. Same options and behavior as /stream/process/upload end point.
     * @param url URL to upload the picture (required)
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param score Score defines the order of the images. Image with lowest score will first in the sequence. If score is not set, then the order will done on the timestamp. (optional)
     * @param time Relative time of the video. Default is 0.0. (optional)
     * @param timestamp Specific timestamp for the picture in the session in UNIX time. Default is the time when you process the image. (optional)
     * @param format Format of the JSON response. Default is v2-Full. (optional)
     * @param distance Distance is the distance at which the picture was taken. Near &#x3D; 1.5 m; Medium &#x3D; 3 m; Far &gt; 3 m. Default value is near. (optional)
     * @param multipleFaces If there are multiple faces in the region of interest, then you need to put this value to True. Default value is true. (optional)
     * @param xMin Minimum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param xMax Maximum horizontal value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param yMin Minimum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 0.0 (optional)
     * @param yMax Maximum vertical value for the region of interest. It should be between 0.0 and 1.0. Default is 1.0 (optional)
     * @param enableFooter Enable the footer with more information on the emotions. Default value is true. (This value is used when rendering the session) (optional)
     * @param dimSecFaces If set to true, it will dim all the secondary faces. Default value is true. (This value is used when rendering the session) (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call streamProcessUrlAsync(String url, String sessionKey, Double score, Double time, Double timestamp, String format, String distance, Boolean multipleFaces, Double xMin, Double xMax, Double yMin, Double yMax, Boolean enableFooter, Boolean dimSecFaces, String appId, String appKey, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = streamProcessUrlCall(url, sessionKey, score, time, timestamp, format, distance, multipleFaces, xMin, xMax, yMin, yMax, enableFooter, dimSecFaces, appId, appKey, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for streamQueryCsv */
    private com.squareup.okhttp.Call streamQueryCsvCall(String sessionKey, String dataFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'sessionKey' is set
        if (sessionKey == null) {
            throw new ApiException("Missing the required parameter 'sessionKey' when calling streamQueryCsv(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stream/query/csv".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (sessionKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sessionKey", sessionKey));
        if (dataFormat != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "dataFormat", dataFormat));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sortBy", sortBy));
        if (limitBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "limitBy", limitBy));
        if (startLimit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startLimit", startLimit));
        if (endLimit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endLimit", endLimit));
        if (order != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "order", order));
        if (appId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appId", appId));
        if (appKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appKey", appKey));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "text/csv"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Query stream based on session key and return data as CSV data format.
     * Query stream based on session key and return data as CSV data format. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param dataFormat Format of the JSON response. Default is basic. (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String streamQueryCsv(String sessionKey, String dataFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey) throws ApiException {
        ApiResponse<String> resp = streamQueryCsvWithHttpInfo(sessionKey, dataFormat, sortBy, limitBy, startLimit, endLimit, order, appId, appKey);
        return resp.getData();
    }

    /**
     * Query stream based on session key and return data as CSV data format.
     * Query stream based on session key and return data as CSV data format. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param dataFormat Format of the JSON response. Default is basic. (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> streamQueryCsvWithHttpInfo(String sessionKey, String dataFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey) throws ApiException {
        com.squareup.okhttp.Call call = streamQueryCsvCall(sessionKey, dataFormat, sortBy, limitBy, startLimit, endLimit, order, appId, appKey, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Query stream based on session key and return data as CSV data format. (asynchronously)
     * Query stream based on session key and return data as CSV data format. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param dataFormat Format of the JSON response. Default is basic. (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call streamQueryCsvAsync(String sessionKey, String dataFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = streamQueryCsvCall(sessionKey, dataFormat, sortBy, limitBy, startLimit, endLimit, order, appId, appKey, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for streamQueryGraph */
    private com.squareup.okhttp.Call streamQueryGraphCall(String sessionKey, String graphFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'sessionKey' is set
        if (sessionKey == null) {
            throw new ApiException("Missing the required parameter 'sessionKey' when calling streamQueryGraph(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stream/query/graph".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (sessionKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sessionKey", sessionKey));
        if (graphFormat != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "graphFormat", graphFormat));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sortBy", sortBy));
        if (limitBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "limitBy", limitBy));
        if (startLimit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startLimit", startLimit));
        if (endLimit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endLimit", endLimit));
        if (order != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "order", order));
        if (appId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appId", appId));
        if (appKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appKey", appKey));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Query stream based on session key and return data as JSON graph format.
     * Query stream based on session key and return data as JSON graph format. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param graphFormat Format of the JSON response. Default is charts-json. (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String streamQueryGraph(String sessionKey, String graphFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey) throws ApiException {
        ApiResponse<String> resp = streamQueryGraphWithHttpInfo(sessionKey, graphFormat, sortBy, limitBy, startLimit, endLimit, order, appId, appKey);
        return resp.getData();
    }

    /**
     * Query stream based on session key and return data as JSON graph format.
     * Query stream based on session key and return data as JSON graph format. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param graphFormat Format of the JSON response. Default is charts-json. (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> streamQueryGraphWithHttpInfo(String sessionKey, String graphFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey) throws ApiException {
        com.squareup.okhttp.Call call = streamQueryGraphCall(sessionKey, graphFormat, sortBy, limitBy, startLimit, endLimit, order, appId, appKey, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Query stream based on session key and return data as JSON graph format. (asynchronously)
     * Query stream based on session key and return data as JSON graph format. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param graphFormat Format of the JSON response. Default is charts-json. (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call streamQueryGraphAsync(String sessionKey, String graphFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = streamQueryGraphCall(sessionKey, graphFormat, sortBy, limitBy, startLimit, endLimit, order, appId, appKey, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for streamQueryImages */
    private com.squareup.okhttp.Call streamQueryImagesCall(String sessionKey, Boolean render, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'sessionKey' is set
        if (sessionKey == null) {
            throw new ApiException("Missing the required parameter 'sessionKey' when calling streamQueryImages(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stream/query/images".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (sessionKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sessionKey", sessionKey));
        if (render != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "render", render));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sortBy", sortBy));
        if (limitBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "limitBy", limitBy));
        if (startLimit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startLimit", startLimit));
        if (endLimit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endLimit", endLimit));
        if (order != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "order", order));
        if (appId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appId", appId));
        if (appKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appKey", appKey));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/zip"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Query stream based on session key and return data as a ZIP file containing the images of the stream.
     * Query stream based on session key and return data as a ZIP file containing the images of the stream. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param render If you want to render the images, set this parameter to true. If set to false, you will receive the raw images. (Default is false) (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String streamQueryImages(String sessionKey, Boolean render, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey) throws ApiException {
        ApiResponse<String> resp = streamQueryImagesWithHttpInfo(sessionKey, render, sortBy, limitBy, startLimit, endLimit, order, appId, appKey);
        return resp.getData();
    }

    /**
     * Query stream based on session key and return data as a ZIP file containing the images of the stream.
     * Query stream based on session key and return data as a ZIP file containing the images of the stream. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param render If you want to render the images, set this parameter to true. If set to false, you will receive the raw images. (Default is false) (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> streamQueryImagesWithHttpInfo(String sessionKey, Boolean render, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey) throws ApiException {
        com.squareup.okhttp.Call call = streamQueryImagesCall(sessionKey, render, sortBy, limitBy, startLimit, endLimit, order, appId, appKey, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Query stream based on session key and return data as a ZIP file containing the images of the stream. (asynchronously)
     * Query stream based on session key and return data as a ZIP file containing the images of the stream. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param render If you want to render the images, set this parameter to true. If set to false, you will receive the raw images. (Default is false) (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call streamQueryImagesAsync(String sessionKey, Boolean render, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = streamQueryImagesCall(sessionKey, render, sortBy, limitBy, startLimit, endLimit, order, appId, appKey, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for streamQueryJson */
    private com.squareup.okhttp.Call streamQueryJsonCall(String sessionKey, String queryFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'sessionKey' is set
        if (sessionKey == null) {
            throw new ApiException("Missing the required parameter 'sessionKey' when calling streamQueryJson(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stream/query/json".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (sessionKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sessionKey", sessionKey));
        if (queryFormat != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "queryFormat", queryFormat));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sortBy", sortBy));
        if (limitBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "limitBy", limitBy));
        if (startLimit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startLimit", startLimit));
        if (endLimit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endLimit", endLimit));
        if (order != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "order", order));
        if (appId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appId", appId));
        if (appKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appKey", appKey));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Query stream based on session key and return data as basic JSON format
     * Query stream based on session key and return data as basic JSON format. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param queryFormat Format of the JSON response. Default is v2-Full. (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String streamQueryJson(String sessionKey, String queryFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey) throws ApiException {
        ApiResponse<String> resp = streamQueryJsonWithHttpInfo(sessionKey, queryFormat, sortBy, limitBy, startLimit, endLimit, order, appId, appKey);
        return resp.getData();
    }

    /**
     * Query stream based on session key and return data as basic JSON format
     * Query stream based on session key and return data as basic JSON format. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param queryFormat Format of the JSON response. Default is v2-Full. (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> streamQueryJsonWithHttpInfo(String sessionKey, String queryFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey) throws ApiException {
        com.squareup.okhttp.Call call = streamQueryJsonCall(sessionKey, queryFormat, sortBy, limitBy, startLimit, endLimit, order, appId, appKey, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Query stream based on session key and return data as basic JSON format (asynchronously)
     * Query stream based on session key and return data as basic JSON format. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param queryFormat Format of the JSON response. Default is v2-Full. (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call streamQueryJsonAsync(String sessionKey, String queryFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = streamQueryJsonCall(sessionKey, queryFormat, sortBy, limitBy, startLimit, endLimit, order, appId, appKey, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for streamQueryVideo */
    private com.squareup.okhttp.Call streamQueryVideoCall(String sessionKey, Integer fps, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'sessionKey' is set
        if (sessionKey == null) {
            throw new ApiException("Missing the required parameter 'sessionKey' when calling streamQueryVideo(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stream/query/video".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (sessionKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sessionKey", sessionKey));
        if (fps != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "fps", fps));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sortBy", sortBy));
        if (limitBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "limitBy", limitBy));
        if (startLimit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startLimit", startLimit));
        if (endLimit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endLimit", endLimit));
        if (order != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "order", order));
        if (appId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appId", appId));
        if (appKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appKey", appKey));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "video/mp4"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Query stream based on session key and return data as a video.
     * Query stream based on session key and return data as a video. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param fps Number of fps of the video. (Default is 30) (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String streamQueryVideo(String sessionKey, Integer fps, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey) throws ApiException {
        ApiResponse<String> resp = streamQueryVideoWithHttpInfo(sessionKey, fps, sortBy, limitBy, startLimit, endLimit, order, appId, appKey);
        return resp.getData();
    }

    /**
     * Query stream based on session key and return data as a video.
     * Query stream based on session key and return data as a video. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param fps Number of fps of the video. (Default is 30) (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> streamQueryVideoWithHttpInfo(String sessionKey, Integer fps, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey) throws ApiException {
        com.squareup.okhttp.Call call = streamQueryVideoCall(sessionKey, fps, sortBy, limitBy, startLimit, endLimit, order, appId, appKey, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Query stream based on session key and return data as a video. (asynchronously)
     * Query stream based on session key and return data as a video. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param fps Number of fps of the video. (Default is 30) (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call streamQueryVideoAsync(String sessionKey, Integer fps, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = streamQueryVideoCall(sessionKey, fps, sortBy, limitBy, startLimit, endLimit, order, appId, appKey, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for streamQueryZip */
    private com.squareup.okhttp.Call streamQueryZipCall(String sessionKey, Boolean render, String queryFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // verify the required parameter 'sessionKey' is set
        if (sessionKey == null) {
            throw new ApiException("Missing the required parameter 'sessionKey' when calling streamQueryZip(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stream/query/zip".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (sessionKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sessionKey", sessionKey));
        if (render != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "render", render));
        if (queryFormat != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "queryFormat", queryFormat));
        if (sortBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "sortBy", sortBy));
        if (limitBy != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "limitBy", limitBy));
        if (startLimit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "startLimit", startLimit));
        if (endLimit != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "endLimit", endLimit));
        if (order != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "order", order));
        if (appId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appId", appId));
        if (appKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appKey", appKey));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/zip"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Query stream based on session key and return data as a ZIP file containging the images as well as the data in the basic JSON format.
     * Query stream based on session key and return data as a ZIP file containging the images as well as the data in the basic JSON format. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param render If you want to render the images, set this parameter to true. If set to false, you will receive the raw images. (Default is false) (optional)
     * @param queryFormat Format of the JSON response. Default is v2-Full. (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return String
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public String streamQueryZip(String sessionKey, Boolean render, String queryFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey) throws ApiException {
        ApiResponse<String> resp = streamQueryZipWithHttpInfo(sessionKey, render, queryFormat, sortBy, limitBy, startLimit, endLimit, order, appId, appKey);
        return resp.getData();
    }

    /**
     * Query stream based on session key and return data as a ZIP file containging the images as well as the data in the basic JSON format.
     * Query stream based on session key and return data as a ZIP file containging the images as well as the data in the basic JSON format. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param render If you want to render the images, set this parameter to true. If set to false, you will receive the raw images. (Default is false) (optional)
     * @param queryFormat Format of the JSON response. Default is v2-Full. (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return ApiResponse&lt;String&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<String> streamQueryZipWithHttpInfo(String sessionKey, Boolean render, String queryFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey) throws ApiException {
        com.squareup.okhttp.Call call = streamQueryZipCall(sessionKey, render, queryFormat, sortBy, limitBy, startLimit, endLimit, order, appId, appKey, null, null);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Query stream based on session key and return data as a ZIP file containging the images as well as the data in the basic JSON format. (asynchronously)
     * Query stream based on session key and return data as a ZIP file containging the images as well as the data in the basic JSON format. The query can be sorted and limited by either the score, time, or timestamp parameters used when processing images of the stream. Results of the query can be ordered ascending or descending.
     * @param sessionKey key to store the processed images in the database. Please use a key generated by the API. (required)
     * @param render If you want to render the images, set this parameter to true. If set to false, you will receive the raw images. (Default is false) (optional)
     * @param queryFormat Format of the JSON response. Default is v2-Full. (optional)
     * @param sortBy This parameter defines how you want to sort the images in the session. Default is timestamp. (optional)
     * @param limitBy This parameter defines the parameters the API will use to limit the data. Default is timestamp. (optional)
     * @param startLimit Starting limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param endLimit Ending limit. It needs to be consistent with the limitBy parameter. (For example, if you&#39;re limiting by timestamp, put here a UNIX time) (optional)
     * @param order This parameters defines the order, ascending or descending. Default is ascending (optional)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call streamQueryZipAsync(String sessionKey, Boolean render, String queryFormat, String sortBy, String limitBy, Double startLimit, Double endLimit, String order, String appId, String appKey, final ApiCallback<String> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = streamQueryZipCall(sessionKey, render, queryFormat, sortBy, limitBy, startLimit, endLimit, order, appId, appKey, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<String>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
    /* Build call for streamStart */
    private com.squareup.okhttp.Call streamStartCall(String id, String data, String appId, String appKey, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = data;
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling streamStart(Async)");
        }
        
        // verify the required parameter 'data' is set
        if (data == null) {
            throw new ApiException("Missing the required parameter 'data' when calling streamStart(Async)");
        }
        

        // create path and map variables
        String localVarPath = "/stream/start".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (id != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "id", id));
        if (appId != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appId", appId));
        if (appKey != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "appKey", appKey));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }

    /**
     * Start a stream with an ID and optional meta-data returning a unique session key.
     * Start a stream with provided ID and returns a unique session key. The session key returned is the ID plus the time stamp and a random string appended together. The provided ID does not need to be unique and can be a maximum of 100 characters in length and is used for querying sessions that also support wild-card searches based on the ID. Optional meta-data can be appended to the stream as key-value pairs that can be returned when querying the stream via /stream/list.
     * @param id ID that will be used to start the session. (required)
     * @param data These data are key-value paired. It should look like {\&quot;string\&quot;: \&quot;value1\&quot;, \&quot;number\&quot;: 123, \&quot;boolean\&quot;: true}. They will be stored in the database. (required)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return Key
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public Key streamStart(String id, String data, String appId, String appKey) throws ApiException {
        ApiResponse<Key> resp = streamStartWithHttpInfo(id, data, appId, appKey);
        return resp.getData();
    }

    /**
     * Start a stream with an ID and optional meta-data returning a unique session key.
     * Start a stream with provided ID and returns a unique session key. The session key returned is the ID plus the time stamp and a random string appended together. The provided ID does not need to be unique and can be a maximum of 100 characters in length and is used for querying sessions that also support wild-card searches based on the ID. Optional meta-data can be appended to the stream as key-value pairs that can be returned when querying the stream via /stream/list.
     * @param id ID that will be used to start the session. (required)
     * @param data These data are key-value paired. It should look like {\&quot;string\&quot;: \&quot;value1\&quot;, \&quot;number\&quot;: 123, \&quot;boolean\&quot;: true}. They will be stored in the database. (required)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @return ApiResponse&lt;Key&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Key> streamStartWithHttpInfo(String id, String data, String appId, String appKey) throws ApiException {
        com.squareup.okhttp.Call call = streamStartCall(id, data, appId, appKey, null, null);
        Type localVarReturnType = new TypeToken<Key>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }

    /**
     * Start a stream with an ID and optional meta-data returning a unique session key. (asynchronously)
     * Start a stream with provided ID and returns a unique session key. The session key returned is the ID plus the time stamp and a random string appended together. The provided ID does not need to be unique and can be a maximum of 100 characters in length and is used for querying sessions that also support wild-card searches based on the ID. Optional meta-data can be appended to the stream as key-value pairs that can be returned when querying the stream via /stream/list.
     * @param id ID that will be used to start the session. (required)
     * @param data These data are key-value paired. It should look like {\&quot;string\&quot;: \&quot;value1\&quot;, \&quot;number\&quot;: 123, \&quot;boolean\&quot;: true}. They will be stored in the database. (required)
     * @param appId Application ID. Used for the authentication (optional)
     * @param appKey Application key. Used for the authentication (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call streamStartAsync(String id, String data, String appId, String appKey, final ApiCallback<Key> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = streamStartCall(id, data, appId, appKey, progressListener, progressRequestListener);
        Type localVarReturnType = new TypeToken<Key>(){}.getType();
        apiClient.executeAsync(call, localVarReturnType, callback);
        return call;
    }
}
